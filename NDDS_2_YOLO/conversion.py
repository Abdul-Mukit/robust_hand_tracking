##################################################
# Instructions
##################################################
# This code converts data generated by NDDS in YOLO-darknet compatible format.


import numpy as np
import glob
import os
from os.path import exists
import json
from PIL import Image
import shutil
import cv2

##################################################
# Functions for converting data
##################################################
def convert(size, box):
    dw = 1./size[0]
    dh = 1./size[1]
    x = (box[0] + box[1])/2.0
    y = (box[2] + box[3])/2.0
    w = box[1] - box[0]
    h = box[3] - box[2]
    x = x*dw
    w = w*dw
    y = y*dh
    h = h*dh
    return (x,y,w,h)

##################################################
# UTILS CODE FOR LOADING THE DATA
##################################################
def default_loader(path):
    return Image.open(path).convert('RGB')

def loadjson(path, objectsofinterest, img):
    """
    Loads the data from a json file.
    If there are no objects of interest, then load all the objects.
    """
    with open(path) as data_file:
        data = json.load(data_file)
    # print (path)
    pointsBelief = []
    boxes = []
    points_keypoints_3d = []
    points_keypoints_2d = []
    pointsBoxes = []
    poses = []
    centroids = []

    translations = []
    rotations = []
    points = []

    for i_line in range(len(data['objects'])):
        info = data['objects'][i_line]
        if not objectsofinterest is None and \
                not objectsofinterest in info['class'].lower():
            continue

        box = info['bounding_box']
        boxToAdd = []

        boxToAdd.append(float(box['top_left'][0]))     # 0 top
        boxToAdd.append(float(box['top_left'][1]))     # 1 left
        boxToAdd.append(float(box["bottom_right"][0])) # 2 bottom
        boxToAdd.append(float(box['bottom_right'][1])) # 3 right
        boxes.append(boxToAdd)

        boxpoint = [(boxToAdd[0], boxToAdd[1]), (boxToAdd[0], boxToAdd[3]),
                    (boxToAdd[2], boxToAdd[1]), (boxToAdd[2], boxToAdd[3])]

        pointsBoxes.append(boxpoint)

        # 3dbbox with belief maps
        points3d = []

        pointdata = info['projected_cuboid']
        for p in pointdata:
            points3d.append((p[0], p[1]))

        # Get the centroids
        pcenter = info['projected_cuboid_centroid']

        points3d.append((pcenter[0], pcenter[1]))
        pointsBelief.append(points3d)
        points.append(points3d + [(pcenter[0], pcenter[1])])
        centroids.append((pcenter[0], pcenter[1]))

        # load translations
        location = info['location']
        translations.append([location[0], location[1], location[2]])

        # quaternion
        rot = info["quaternion_xyzw"]
        rotations.append(rot)

    return {
        "pointsBelief": pointsBelief,
        "rotations": rotations,
        "translations": translations,
        "centroids": centroids,
        "points": points,
        "keypoints_2d": points_keypoints_2d,
        "keypoints_3d": points_keypoints_3d,
        'bounding_boxes': pointsBoxes
    }

def loadimages(root):
    """
    Find all the images in the path and folders, return them in imgs.
    """
    imgs = []

    def add_json_files(path, ):
        imgpaths = glob.glob(path + "/*.png")
        imgpaths.sort()
        for imgpath in imgpaths:
            if exists(imgpath) and exists(imgpath.replace('png', "json")):
                imgs.append((imgpath, imgpath.replace(path, "").replace("/", ""),
                             imgpath.replace('png', "json")))

    def explore(path):
        if not os.path.isdir(path):
            return
        folders = [os.path.join(path, o) for o in os.listdir(path)
                   if os.path.isdir(os.path.join(path, o))]
        if len(folders) > 0:
            for path_entry in folders:
                explore(path_entry)
        else:
            add_json_files(path)

    explore(root)

    return imgs

def load_data(path):
    '''Recursively load the data.  This is useful to load all of the FAT dataset.'''
    imgs = loadimages(path)

    # Check all the folders in path
    for name in os.listdir(str(path)):
        imgs += loadimages(path + "/" + name)
    return imgs


##################################################
# Start code
##################################################
NDDS_data_path = '/media/drive1/Datasets/UE4/yolo_cautery/simple'

# prob_idxs = [-1] 1043, 1341
prob_idxs = [-1]

objectsofinterest = 'my_cautery'

train_percent = 0.8  # the percentage of data for training

im_width  = 512 # Check camera_settings.json
im_height = 512 # Check camera_settings.json

trainList_fname = 'train.txt'
testList_fname = 'test.txt'

ndds_data = load_data(NDDS_data_path)
imgLoader = default_loader

# Clear out previous outputs (labels, mask folders and train.txt, test.txt files)
if os.path.isdir('labels'):
    shutil.rmtree('labels')
    print('Previous "labels" folder removed !')

if os.path.isdir('images'):
    shutil.rmtree('images')
    print('Previous "images" folder removed !')

if os.path.isfile(trainList_fname):
    os.remove(trainList_fname)
    print('Previous ' + trainList_fname + ' file removed !')

if os.path.isfile(testList_fname):
    os.remove(testList_fname)
    print('Previous ' + testList_fname + ' file removed !')

# Creating folders and files for storing results
os.makedirs('labels')
os.makedirs('images')
f_train = open(trainList_fname, 'w+')
f_test = open(testList_fname, 'w+')

# Going through each sample while voiding the ones in the prob_idxs array
train_marker = int(ndds_data.__len__() * train_percent)


# for index in range(prob_idxs[-1], ndds_data.__len__()):
for index in range(ndds_data.__len__()):
    print(index)
    # skipping images with problems (don't know the reason for problems)
    if True in (index == prob_idx for prob_idx in prob_idxs):
        print('Skipped '+str(index))
        continue

    # Loading NDDS data
    path, name, txt = ndds_data[index]
    try:
        img = imgLoader(path)
    except:
        print('Skipped ' + str(index))
        continue

    jsonLoader = loadjson
    jsonData = jsonLoader(txt, objectsofinterest, img)

    try:
        boxes2d = np.array(jsonData['bounding_boxes'], dtype="float")
    except:
        print('Skipped ' + str(index))
        continue

    # Converting Data to YOLO format
    txtholder = []
    for box2d in boxes2d:
        labelrow = [0, 0, 0, 0, 0]
        min_y, min_x = box2d[0]
        max_y, max_x = box2d[3]
        labelrow[1:] = convert((im_width, im_height), [min_x, max_x, min_y, max_y])
        txtholder.append(labelrow)

    # Save as label .txt files
    label_fname = 'labels/' + name.replace('.png', '.txt')
    np.savetxt(label_fname, txtholder, fmt='%1.6f')

    # Appending new path to train/test.txt
    cur_dir = os.path.dirname(os.path.realpath(__file__))
    new_img_path = cur_dir+'/images/'+name
    if index >= train_marker:
        f_test.write(new_img_path + '\n')
    else:
        f_train.write(new_img_path + '\n')

    # Save original images in the "images" folder
    img.save('images/' + name, 'PNG')

# Wrapping up
f_train.close()
f_test.close()
print('Images copied in "images" folder')
print('Labels generated in "labels" folder')
print('Image paths written in "' + trainList_fname +'" and "' + testList_fname + '" file')


